<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Notes</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_0.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Types</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Slice Type</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Structs</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">11.</strong> Methods</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">12.</strong> Enums</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">13.</strong> match</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">14.</strong> if let</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">15.</strong> Packages, Crates and Modules</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">16.</strong> use</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">17.</strong> Modules</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">18.</strong> Vector</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">19.</strong> Strings</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">20.</strong> Hashmap</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">21.</strong> Chapter 20</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Notes</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#intro" id="intro">Intro</a></h1>
<p>These notes are an abridged version of <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> book.</p>
<p><a href="https://github.com/anselbrandt/rust-notes">Download notes</a></p>
<h2><a class="header" href="#guessing-game" id="guessing-game">Guessing Game</a></h2>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }

}
</code></pre>
<h2><a class="header" href="#variables-and-mutability" id="variables-and-mutability">Variables and Mutability</a></h2>
<h3><a class="header" href="#mutability" id="mutability">Mutability</a></h3>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<h3><a class="header" href="#constants" id="constants">Constants</a></h3>
<pre><code class="language-rust ignore">const MAX_POINTS: u32 = 100_000;
</code></pre>
<h3><a class="header" href="#shadowing" id="shadowing">Shadowing</a></h3>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>Shadowing permits type mutation:</p>
<pre><code class="language-rust ignore"> let spaces = &quot;   &quot;;
 let spaces = spaces.len();
</code></pre>
<h2><a class="header" href="#types" id="types">Types</a></h2>
<h3><a class="header" href="#scaler-types" id="scaler-types">Scaler Types</a></h3>
<p>Integers, floating-point numbers, Booleans, and characters</p>
<h4><a class="header" href="#integer" id="integer">Integer</a></h4>
<p>Integer Types</p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch dep</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Integer Literals</p>
<table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<h4><a class="header" href="#floating-point" id="floating-point">Floating-Point</a></h4>
<p>Defaults to <code>f64</code></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
<h4><a class="header" href="#boolean" id="boolean">Boolean</a></h4>
<pre><code class="language-rust ignore">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
<h4><a class="header" href="#character" id="character">Character</a></h4>
<p><code>char</code> literals specified with single quoates, as opposed to string literals using double quotes</p>
<pre><code class="language-rust ignore">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
<p>Rust’s <code>char</code> type is four bytes in size and represents a Unicode Scalar Value from <code>U+0000</code> to <code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code></p>
<h3><a class="header" href="#compoound-types" id="compoound-types">Compoound Types</a></h3>
<p>Tuples and arrays</p>
<h4><a class="header" href="#tuple" id="tuple">Tuple</a></h4>
<pre><code class="language-rust ignore">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
<p>Accessing tuple elements with <code>.</code> notation</p>
<pre><code class="language-rust ignore">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre>
<h4><a class="header" href="#array" id="array">Array</a></h4>
<p>Arrays have fixed length and elements of the same type</p>
<pre><code class="language-rust ignore">let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
<p>Initializing and filling an array with elements <code>3</code> and length <code>5</code>:</p>
<pre><code class="language-rust ignore">let a = [3; 5];
</code></pre>
<p>Accessing array elements:</p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<h4><a class="header" href="#return-values" id="return-values">Return Values</a></h4>
<p>Return values are expressions without end of line semicolons. Semicolons denote statements.</p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<h2><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h2>
<h3><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> Expressions</a></h3>
<h4><a class="header" href="#multiple-conditions-with-else-if" id="multiple-conditions-with-else-if">Multiple Conditions with <code>else if</code></a></h4>
<pre><code class="language-rust ignore">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre>
<h4><a class="header" href="#using-if-in-a-let-statement" id="using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> Statement</a></h4>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<h3><a class="header" href="#loops" id="loops">Loops</a></h3>
<h4><a class="header" href="#return-values-from-loops" id="return-values-from-loops">Return Values from Loops</a></h4>
<pre><code class="language-rust ignore">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre>
<h4><a class="header" href="#conditional-loops-with-while" id="conditional-loops-with-while">Conditional Loops with <code>while</code></a></h4>
<pre><code class="language-rust ignore">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre>
<h4><a class="header" href="#looping-through-a-collection-with-for" id="looping-through-a-collection-with-for">Looping Through a Collection with <code>for</code></a></h4>
<pre><code class="language-rust ignore">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre>
<h3><a class="header" href="#-rev-method" id="-rev-method">* <code>rev</code> method</a></h3>
<pre><code class="language-rust ignore">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre>
<h2><a class="header" href="#ownership" id="ownership">Ownership</a></h2>
<ul>
<li>Each value has a variable called its <em>owner</em></li>
<li>There can only be one owner at a time</li>
<li>When the owner goes out of scope, the value is dropped</li>
</ul>
<p>Ownership applies to data types of non-fixed size stored on the heap</p>
<p>eg. <code>String</code> as opposed to string literals:</p>
<pre><code class="language-rust ignore">    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
</code></pre>
<h3><a class="header" href="#variables-and-data" id="variables-and-data">Variables and Data</a></h3>
<pre><code class="language-rust ignore"> let s1 = String::from(&quot;hello&quot;);
 let s2 = s1;
</code></pre>
<p>Both <code>s1</code> and <code>s2</code> are pointers on the stack to data on the heap.</p>
<p>Once a variable goes out of scope, Rust calls the <code>drop</code> function to clean up the heap memory for that variable.</p>
<p>Assigning <code>s1</code> to <code>s2</code> invalidates the reference <code>s1</code>. <code>s1</code> is <em>moved</em> into <code>s2</code>. Invalidating the first variable prevents the <em>double free</em> error.</p>
<h3><a class="header" href="#clone" id="clone">Clone</a></h3>
<p>If a deep copy is desired:</p>
<pre><code class="language-rust ignore">   let s1 = String::from(&quot;hello&quot;);
   let s2 = s1.clone();

   println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
</code></pre>
<h3><a class="header" href="#stack-only-data-copy" id="stack-only-data-copy">Stack-Only Data: Copy</a></h3>
<pre><code class="language-rust ignore">    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
</code></pre>
<p>Data types of known size are stored on the stack and posess the <code>Copy</code> trait.</p>
<ul>
<li>Integer types</li>
<li>Boolean, <code>bool</code></li>
<li>Floating point types</li>
<li>Character, <code>char</code></li>
<li>Tuples, if all elements are type <code>Copy</code></li>
</ul>
<h2><a class="header" href="#references-and-borrowing" id="references-and-borrowing">References and Borrowing</a></h2>
<p>The <code>calculate_length</code> function takes a reference <code>&amp;</code> to an object as a parameter instead of taking ownership of the value:</p>
<pre><code class="language-rust ignore">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
<blockquote>
<p>Values can be dereferenced with the dereference operator <code>*</code></p>
</blockquote>
<h3><a class="header" href="#mutable-references" id="mutable-references">Mutable References</a></h3>
<p>Data can have at most one mutable reference:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p>This restriction prevents data races:</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>There’s no mechanism being used to synchronize access to the data.</li>
</ul>
<p>Creating a new scope with curly brackets allows for multiple mutable references, just not <em>simultaneous</em> ones:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
</code></pre>
<p>However, you cannot have a a mutable reference while also having an immutable one, unless all immutable references are out of scope:</p>
<pre><code class="language-rust ignore"> let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // r1 and r2 are no longer used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
</code></pre>
<h3><a class="header" href="#dangling-references" id="dangling-references">Dangling References</a></h3>
<p>The Rust compiler will check for dangling references to values that are out of scope:</p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<h2><a class="header" href="#slice-type" id="slice-type">Slice Type</a></h2>
<p>Slices reference a contiguous sequence of elements in a collection. Slices do not have ownership.</p>
<h3><a class="header" href="#string-slice" id="string-slice">String Slice</a></h3>
<p>A <em>string slice</em> is a reference to part of a <code>String</code>.</p>
<pre><code class="language-rust ignore"> let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
</code></pre>
<p>Starting and trailing indices are optional:</p>
<pre><code class="language-rust ignore">let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];

let slice = &amp;s[3..len];
let slice = &amp;s[3..];

let slice = &amp;s[0..len];
let slice = &amp;s[..];
</code></pre>
<p>Example function returning string slice, <code>&amp;str</code>:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</code></pre>
<p>Where <code>enumerate</code> returns a tuple of <code>i</code> and <code>&amp;item</code></p>
<h3><a class="header" href="#string-literals-are-slices" id="string-literals-are-slices">String Literals are Slices</a></h3>
<p>String literals are stored inside the binary and are slices pointing to a specific point of the binary.</p>
<pre><code class="language-rust ignore">let s = &quot;Hello, world!&quot;;
</code></pre>
<p>Therefore <code>s</code> is of type <code>&amp;str</code> and is immutable, as string slices are immutable references.</p>
<h3><a class="header" href="#other-slices" id="other-slices">Other Slices</a></h3>
<p>Array slices:</p>
<pre><code class="language-rust ignore">let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
</code></pre>
<p>This slice has type <code>&amp;[i32]</code></p>
<h2><a class="header" href="#structs" id="structs">Structs</a></h2>
<h4><a class="header" href="#defining" id="defining">Defining</a></h4>
<pre><code class="language-rust ignore">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
</code></pre>
<h4><a class="header" href="#instantiating" id="instantiating">Instantiating</a></h4>
<pre><code class="language-rust ignore">    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
</code></pre>
<p>An entire instance must be either immutable or mutable.</p>
<h4><a class="header" href="#field-init-shorthand-when-variables-and-fields-have-same-name" id="field-init-shorthand-when-variables-and-fields-have-same-name">Field Init Shorthand when Variables and Fields Have Same Name</a></h4>
<pre><code class="language-rust ignore">fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre>
<h4><a class="header" href="#creating-instances-from-other-instances" id="creating-instances-from-other-instances">Creating Instances from Other Instances</a></h4>
<pre><code class="language-rust ignore">    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        username: String::from(&quot;anotherusername567&quot;),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
</code></pre>
<p>or</p>
<pre><code class="language-rust ignore">    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        username: String::from(&quot;anotherusername567&quot;),
        ..user1
    };
</code></pre>
<h3><a class="header" href="#tuple-structs-without-named-fields" id="tuple-structs-without-named-fields">Tuple Structs without Named Fields</a></h3>
<pre><code class="language-rust ignore">    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
</code></pre>
<h3><a class="header" href="#example-program-using-structs" id="example-program-using-structs">Example Program Using Structs</a></h3>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre>
<p>The specifier <code>:?</code> tells <code>println!</code> to use format <code>Debug</code></p>
<p>To implement the <code>Debug</code> trait on <code>Rectangle</code> we must add the annotation <code>#[derive(Debug)]</code> before the struct.</p>
<h2><a class="header" href="#methods" id="methods">Methods</a></h2>
<h3><a class="header" href="#defining-methods" id="defining-methods">Defining Methods</a></h3>
<p>Methods are defined within <code>impl</code> blocks. Structs can have multiple <code>impl</code> blocks.</p>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre>
<blockquote>
<p>Rust uses <em>automatic referencing</em> and <em>dereferencing</em> when calling methods.
When you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so object matches the signature of the method.</p>
<pre><code class="language-rust ignore">p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
</code></pre>
<p>Automatic referencing works because methods have a clear receiver—the type of <em>self</em>. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (<em>&amp;self</em>), mutating (<em>&amp;mut self</em>), or consuming (<em>self</em>).</p>
</blockquote>
<h3><a class="header" href="#methods-with-more-parameters" id="methods-with-more-parameters">Methods with More Parameters</a></h3>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<h3><a class="header" href="#associated-functions" id="associated-functions">Associated Functions</a></h3>
<p>Associated functions are often used for constructors that will return a new instance of the struct.</p>
<pre><code class="language-rust ignore">impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
</code></pre>
<p>The <code>square</code> function is namespaced by the struct and called with the <code>::</code> syntax: <code>let sq = Rectangle::square(3);</code></p>
<h2><a class="header" href="#enumerations" id="enumerations">Enumerations</a></h2>
<h4><a class="header" href="#defining-enums" id="defining-enums">Defining Enums</a></h4>
<pre><code class="language-rust ignore">enum IpAddrKind {
    V4,
    V6,
}
</code></pre>
<p>Variations of enums are namespaced under their identifier.</p>
<pre><code class="language-rust ignore"> let four = IpAddrKind::V4;
 let six = IpAddrKind::V6;
</code></pre>
<h4><a class="header" href="#enum-associated-values" id="enum-associated-values">Enum Associated Values</a></h4>
<pre><code class="language-rust ignore">    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>
<p>Enum variants can have different types and amounts of associated data.</p>
<pre><code class="language-rust ignore">   enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>
<p>or</p>
<pre><code class="language-rust ignore">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
<ul>
<li><code>Quit</code> has no data associated with it at all.</li>
<li><code>Move</code> includes an anonymous struct inside it.</li>
<li><code>Write</code> includes a single <code>String</code>.</li>
<li><code>ChangeColor</code> includes three <code>i32</code> values.</li>
</ul>
<h4><a class="header" href="#methods-on-enums" id="methods-on-enums">Methods on Enums</a></h4>
<pre><code class="language-rust ignore">    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
</code></pre>
<h3><a class="header" href="#option-enum" id="option-enum">Option Enum</a></h3>
<p>Rust does not have null, but has <code>Option</code> type, which can be something or nothing.</p>
<p>It is defined by the standard library as follows:</p>
<pre><code class="language-rust ignore">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
<p><code>Option&lt;T&gt;</code>, <code>Some</code> and <code>None</code> are included in the prelude and do not need to be brought into scope, and therefore do not require the <code>Option::</code> prefix.</p>
<pre><code class="language-rust ignore">    let some_number = Some(5);
    let some_string = Some(&quot;a string&quot;);

    let absent_number: Option&lt;i32&gt; = None;
</code></pre>
<p>If a variable is initialized with <code>None</code> a type needs to be specified in the generic.</p>
<h4><a class="header" href="#does-not-compile" id="does-not-compile">Does not compile:</a></h4>
<pre><code class="language-rust ignore">    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
</code></pre>
<h4><a class="header" href="#optiont-must-be-converted-to-t-before-performing-t-operations-with-it" id="optiont-must-be-converted-to-t-before-performing-t-operations-with-it">*<code>Option&lt;T&gt;</code> must be converted to <code>T</code> before performing <code>T</code> operations with it.</a></h4>
<p>(see next section)</p>
<h2><a class="header" href="#match-control-flow-operator" id="match-control-flow-operator"><code>match</code> Control Flow Operator</a></h2>
<pre><code class="language-rust ignore">fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
<h4><a class="header" href="#patterns-that-bind-to-values" id="patterns-that-bind-to-values">Patterns that Bind to Values</a></h4>
<pre><code class="language-rust ignore">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
</code></pre>
<pre><code class="language-rust ignore">fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
</code></pre>
<p>If we call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> the binding for <code>state</code> will be the value <code>UsState::Alaska</code></p>
<h4><a class="header" href="#matching-with-optiont" id="matching-with-optiont">Matching with Option&lt;T&gt;</a></h4>
<pre><code class="language-rust ignore">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
</code></pre>
<p>Combining <code>match</code> and enums is a common pattern in Rust:</p>
<ol>
<li><code>match</code> against an enum</li>
<li>bind a variable to the data inside</li>
<li>execute code execute code based on it</li>
</ol>
<h4><a class="header" href="#the-_-placeholder" id="the-_-placeholder">The _ Placeholder</a></h4>
<pre><code class="language-rust ignore">    let some_u8_value = 0u8;
    match some_u8_value {
        1 =&gt; println!(&quot;one&quot;),
        3 =&gt; println!(&quot;three&quot;),
        5 =&gt; println!(&quot;five&quot;),
        7 =&gt; println!(&quot;seven&quot;),
        _ =&gt; (),
    }
</code></pre>
<p>As matches are exhaustive, the <code>_</code> pattern will match all cases not specified.</p>
<h2><a class="header" href="#concise-control-flow-with-if-let" id="concise-control-flow-with-if-let">Concise Control Flow with <code>if let</code></a></h2>
<pre><code class="language-rust ignore">    let some_u8_value = Some(0u8);
    match some_u8_value {
        Some(3) =&gt; println!(&quot;three&quot;),
        _ =&gt; (),
    }
</code></pre>
<p>equivalent to:</p>
<pre><code class="language-rust ignore">    if let Some(3) = some_u8_value {
        println!(&quot;three&quot;);
    }
</code></pre>
<p><code>if let</code> is more concise than <code>match</code> but does not provide exhaustive checking</p>
<p>Combining <code>if let</code> with <code>else</code></p>
<pre><code class="language-rust ignore">    if let Some(3) = some_u8_value {
        println!(&quot;three&quot;);
    } else {
        println!(&quot;not three&quot;);
    }
</code></pre>
<h2><a class="header" href="#packages-crates-and-modules" id="packages-crates-and-modules">Packages, Crates and Modules</a></h2>
<ul>
<li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that produces a library or executable</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and
privacy of paths</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
<h3><a class="header" href="#packages-and-crates" id="packages-and-crates">Packages and Crates</a></h3>
<p>Crates are binary packages or library packages.</p>
<p>Binary packages are created with <code>cargo new</code> and have <code>src/main.rs</code> as the crate root.</p>
<p>Library crates are created with <code>cargo new --lib</code> and have <code> src/lib.rs</code> as the crate root.</p>
<h3><a class="header" href="#modules" id="modules">Modules</a></h3>
<p>src/lib.rs</p>
<pre><code class="language-rust ignore">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p>The crate's <em>module tree</em>:</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<h3><a class="header" href="#paths" id="paths">Paths</a></h3>
<ul>
<li><em>absolute path</em> starts from a crate root by using a crate name or a
literal <code>crate</code>.</li>
<li><em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or
an identifier in the current module.</li>
</ul>
<pre><code class="language-rust ignore">mod front_of_house {
    mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>Prefer to specify absolute paths because it’s more likely to move code definitions and item calls independently of each other.</p>
<h3><a class="header" href="#exposing-paths-with-pub-keyword" id="exposing-paths-with-pub-keyword">Exposing Paths with <code>pub</code> Keyword</a></h3>
<p>Items in modules are private by default.</p>
<p>The <code>pub</code> keyword on a module only lets code in its ancestor modules refer to it.</p>
<h3><a class="header" href="#starting-relative-paths-with-super" id="starting-relative-paths-with-super">Starting Relative Paths with <code>super</code></a></h3>
<p>Similar to filesystem <code>..</code>, wen can construct relative paths that begin in the parent module by using <code>super</code>.</p>
<pre><code class="language-rust ignore">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
</code></pre>
<h3><a class="header" href="#making-structs-and-enums-public" id="making-structs-and-enums-public">Making Structs and Enums Public</a></h3>
<p>Fields in a <code>struct</code> are made public on a case-by-case basis.</p>
<p>If an <code>enum</code> is made public, all its variants are then public.</p>
<pre><code class="language-rust ignore">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    pub enum Appetizer {
        Soup,
        Salad,
    }
}
</code></pre>
<h2><a class="header" href="#bringing-paths-into-scope-with-use" id="bringing-paths-into-scope-with-use">Bringing Paths into Scope with <code>use</code></a></h2>
<pre><code class="language-rust ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;
// or relative path:
// use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p>When bringing in structs, enums, and other items with <code>use</code>, it’s idiomatic to specify the full path:</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre>
<h3><a class="header" href="#providing-new-names-with-the-as-keyword" id="providing-new-names-with-the-as-keyword">Providing New Names with the <code>as</code> Keyword</a></h3>
<pre><code class="language-rust ignore">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
}
</code></pre>
<h3><a class="header" href="#re-exporting-names-with-pub-use" id="re-exporting-names-with-pub-use">Re-exporting Names with <code>pub use</code></a></h3>
<pre><code class="language-rust ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<h3><a class="header" href="#nested-paths" id="nested-paths">Nested Paths</a></h3>
<pre><code class="language-rust ignore">// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
</code></pre>
<p>becomes:</p>
<pre><code class="language-rust ignore">// --snip--
use std::{cmp::Ordering, io};
// --snip--
</code></pre>
<p>If items share subpath:</p>
<pre><code class="language-rust ignore">use std::io;
use std::io::Write;
</code></pre>
<p>becomes:</p>
<pre><code class="language-rust ignore">use std::io::{self, Write};
</code></pre>
<h3><a class="header" href="#glob-operator" id="glob-operator">Glob Operator</a></h3>
<pre><code class="language-rust ignore">use std::collections::*;
</code></pre>
<p>Glob can obfuscate what names are in scope and where a name used in your program was defined.</p>
<h2><a class="header" href="#modules-1" id="modules-1">Modules</a></h2>
<p>Using a semicolon after mod <code>front_of_house</code> rather than using a block tells Rust to load the contents of the module from another file with the same name as the module.</p>
<p>src/lib.rs</p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p>src/front_of_house.rs</p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p>Module filenames may also be the name of the module as a directory with the contents in a file named <code>mod.rs</code> within that directory.</p>
<h2><a class="header" href="#vector" id="vector"><em>vector</em></a></h2>
<p>Vectors are a collection whose values must be of the same type.</p>
<h4><a class="header" href="#creating-a-new-vector" id="creating-a-new-vector">Creating a New Vector</a></h4>
<pre><code class="language-rust ignore">let v: Vec&lt;i32&gt; = Vec::new();
</code></pre>
<h4><a class="header" href="#updating-a-vector" id="updating-a-vector">Updating a Vector</a></h4>
<pre><code class="language-rust ignore">    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<h4><a class="header" href="#dropping-a-vector-drops-its-elements" id="dropping-a-vector-drops-its-elements">Dropping a Vector Drops Its Elements</a></h4>
<p>A vector is freed when it goes out of scope.</p>
<pre><code class="language-rust ignore">    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
</code></pre>
<h4><a class="header" href="#reading-elements-of-vectors" id="reading-elements-of-vectors">Reading Elements of Vectors</a></h4>
<pre><code class="language-rust ignore">    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    match v.get(2) {
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
</code></pre>
<p>The <code>[]</code> method gives a reference and will cause a panic if it references a nonexistant element.</p>
<p>The <code>get</code> method gives an <code>Option&lt;T&gt;</code> and will return <code>None</code> without panicking if the index passed is outside the vector.</p>
<p>When the program has a valid reference, the borrow checker enforeces ownership and borrowing rules on the reference.</p>
<p>The following will panic:</p>
<pre><code class="language-rust ignore">    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
</code></pre>
<p>Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory.</p>
<h4><a class="header" href="#iterating-over-the-values-in-a-vector" id="iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h4>
<pre><code class="language-rust ignore">    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
</code></pre>
<p>Iterating over mutable references to make changes to all elements:</p>
<pre><code class="language-rust ignore">    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
</code></pre>
<p>To change the value that the mutable reference refers to, we have to use the dereference operator (<code>*</code>) to get to the value in <code>i</code> before we can use the <code>+=</code> operator.</p>
<h4><a class="header" href="#using-an-enum-to-store-multiple-types" id="using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h4>
<pre><code class="language-rust ignore">    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
</code></pre>
<p>Using an enum plus a <code>match</code> expression means that Rust will ensure at compile time that every possible case is handled.</p>
<h2><a class="header" href="#strings" id="strings">Strings</a></h2>
<p>String slices <code>str</code>, in the core language, usually used in borrowed form <code>&amp;str</code>, are references to UTF-8 encoded string data.</p>
<p>String literals, stored in the binary, are string slices.</p>
<p>The <code>String</code> type, from the standard library, is a growable, mutable, owned UTF-8 encoded string type.</p>
<p>The standard library also includes <code>OsString</code>, <code>OsStr</code>, <code>CString</code> and <code>CStr</code>.</p>
<h3><a class="header" href="#creating-a-new-string" id="creating-a-new-string">Creating a New String</a></h3>
<pre><code class="language-rust ignore">    let mut s = String::new();
</code></pre>
<h4><a class="header" href="#creating-a-string-from-a-string-literal" id="creating-a-string-from-a-string-literal">Creating a <code>String</code> from a string literal</a></h4>
<pre><code class="language-rust ignore">    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
</code></pre>
<pre><code class="language-rust ignore">    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;你好&quot;);
</code></pre>
<h3><a class="header" href="#updating-a-string" id="updating-a-string">Updating a String</a></h3>
<pre><code class="language-rust ignore">    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
</code></pre>
<p><code>push_str</code> takes a string slice and does not assume ownership of the parameter.</p>
<pre><code class="language-rust ignore">    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
</code></pre>
<p><code>push</code> takes a single character</p>
<h3><a class="header" href="#concatenation-with-the--operator-or-the-format-macro" id="concatenation-with-the--operator-or-the-format-macro">Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro</a></h3>
<pre><code class="language-rust ignore">    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
</code></pre>
<p>The <code>+</code> operator requires a <em>reference</em> to a <code>str</code> as the second parameter because the function signature for <code>add</code> looks like this:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Event though <code>s2</code> is a <code>String</code> Rust can <em>coerce</em> <code>&amp;String</code> into a <code>&amp;str</code>. When calling <code>add</code>, Rust uses a <em>deref coercion</em> to turn <code>&amp;s2</code> into <code>&amp;s2[..]</code>.</p>
<p>For more complicated string combining, we can use the <code>format!</code> macro:</p>
<pre><code class="language-rust ignore">    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
</code></pre>
<p><code>format!</code> does not take ownership of any parameters.</p>
<h3><a class="header" href="#indexing-into-strings" id="indexing-into-strings">Indexing into Strings</a></h3>
<p>Because <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code> you cannot access individual characters by referencing them by index as UTF-8 characters may be 1 or more bytes.</p>
<h3><a class="header" href="#slicing-strings" id="slicing-strings">Slicing Strings</a></h3>
<p>If it is necessary to use indices to create string slices, a range <code>[]</code> must be specified:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
</code></pre>
<p>*If the range does not line up with a character boundary, the program will panic.</p>
<h3><a class="header" href="#iterating-over-strings" id="iterating-over-strings">Iterating Over Strings</a></h3>
<p><code>char</code></p>
<pre><code class="language-rust ignore">for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
</code></pre>
<p><code>bytes</code></p>
<pre><code class="language-rust ignore">for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
</code></pre>
<h2><a class="header" href="#hash-map" id="hash-map"><em>hash map</em></a></h2>
<h1><a class="header" href="#chapter-20" id="chapter-20">Chapter 20</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
